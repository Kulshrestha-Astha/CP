//recursion +memoisation
class Solution {
public:
int t[501][501];
int solve(vector<int>& satisfaction,int n,int i,int time)
{
 if(t[i][time]!=-1)return t[i][time];
   if(i>=n)return 0;
   int include=satisfaction[i]*time +solve(satisfaction,n,i+1,time+1);
   int exclude=solve(satisfaction,n,i+1,time);
   return t[i][time]=max(include,exclude);
}
    int maxSatisfaction(vector<int>& satisfaction) {
        int n=satisfaction.size();
        sort(satisfaction.begin(),satisfaction.end());
        memset(t,-1,sizeof(t));
       return solve(satisfaction,n,0,1);
    }
};









//bottom up approach
class Solution {
public:
    int maxSatisfaction(vector<int>& satisfaction) {
        int n=satisfaction.size();
        sort(satisfaction.begin(),satisfaction.end());
        vector<vector<long long>>t(501,vector<long long>(501,INT_MIN));
        for(int i=0;i<501;i++)
        {
           t[i][0]=0;
        }
       t[0][1]=satisfaction[0];//cook 0 dish at time 1
        for(int i=1;i<n;i++)//satisfaction
        {
            for(int ti=1;ti<=n;ti++)
            {
                long long include=satisfaction[i]*ti+t[i-1][ti-1];
                long long exclude=t[i-1][ti];
                 t[i][ti]=max(include,exclude);
            }
           

        }
        long long ans=0;
        for(int i=1;i<=n;i++)
        {
            ans=max(ans,t[n-1][i]);
        }
        return ans;
    }
};
